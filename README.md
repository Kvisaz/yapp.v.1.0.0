# Test Yandex Translate App
Приложение для Android на языке Java. Реализованный минимальный функционал:

- Перевод с одного языка на другой с помощью API Яндекс.Переводчика.
- Поле для ввода текста, который будет переведён на другой язык; переключатель языка и варианты перевода, которые появляются, когда пользователь вводит текст в поле.
- Возможность добавить переведённое слово или предложение в избранное.
- Возможность просмотра истории переводов.
- Возможность просмотра избранного.

![Экран 1](/pics/screen011.png) ![Экран 2](/pics/screen02.png) ![Экран 3](/pics/screen03.png)

### Дополнительный функционал
По дизайну скриншотов к заданию был реализован дополнительный функционал:

- Голосовой ввод текста для перевода с использованием API Яндекс.SpeechKit
- Вокализация исходного текста и переведенного текста с использованием  API Яндекс.SpeechKit
- Вывод словарной статьи для ряда языков через API Яндекс.Словаря
- Поиск по началу слова в Истории и Закладках
- Множественный выбор и удаление пунктов в Истории и закладках 

### Архитектура и работа приложения
При запуске в StartActivity происходит подключение к серверу и забор актуальной информации по доступным языкам для перевода. 

При ошибке подключения к серверу или отсутствии выводится экран с сообщением об ошибке. Экран переводчика неактивен, доступна только кнопка для проверки соединения. Пользователь может искать ранее сохраненные переводы в закладках и истории.

При нормальном подключении запускается TabActivity с ViewPager, в котором расположено три фрагмента
 
- переводчик
- история/закладки
- настройки (пустой экран, не успел реализовать)

Каждый реализованный экран сделан по модели MVP. Фрагменты-вью отвечают только за отображение переданных данных, презентер инкапсулирует в себе работу с сетью и базой данных. Презентер сохраняется при смене ориентации экрана и позволяет восстанавливать последние данные.

### Работа с сетью и базой данных
Работа с API и базой данных сделана в виде отдельных сервисов, запросы к которым осуществляются асинхронно. 

Дополнительно сделан TranslateRepository, чтобы инкапсулировать логику для работы с переводом, которая выполняется таким образом

1. Проверяется наличие перевода в базе данных. 
2. При наличии перевода в базе - возвращается он
3. Если перевода нет - запрашивается комплексный запрос к API.Переводчика и API.Словарям. При выполнении обеих запросов формируется новый перевод, который выводится на экран и записывается в базу данных.

Поиск в базе идет по исходному тексту, исходному языку и языку перевода. Это позволяет сохранять переводы с одним исходным текстом и разными целевыми языками.

### Использованные библиотеки

Кроме библиотек Яндекс.SpeechKit и стандартных библиотек для Android были выбраны следующие решения:

- <a href="https://github.com/Arello-Mobile/Moxy">Moxy</a> для реализации MVP-подхода. Выбрана за то, что автоматически позволяет сохранять презентер при смене ориентации экрана.

- <a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a> для удобной работы с асинхронными запросами и коллбэками. 

- <a href="http://google.github.io/dagger/">Dagger 2</a> для того, чтобы инжектировать репозитории, сервисы и некоторые другие объекты, а не передавать их в презентеры или создавать на месте.

- <a href="http://square.github.io/retrofit/">Retrofit 2</a> поскольку это очень хорошая библиотека для работы с сетевыми запросами, кардинально облегчающая разработку даже для новичков.

- <a href="https://bitbucket.org/littlerobots/cupboard">Cupboard</a> для небольшого облегчения для работы с базой данных. При выборе ORM я склонялся к <a href="https://realm.io/">Realm</a>, но решил таки применить Cupboard, так как она легче, а также для того, чтобы лишний раз потренироваться с базовыми операциями с SQLite

- <a href="http://jakewharton.github.io/butterknife/">ButterKnife</a> из-за быстрого инжектирования View и удобства работы с коллбэками для них

- <a href="https://github.com/biodunalfet/SlidingSquaresLoader">SlidingSquaresLoader</a> просто потому, что это забавный ProgressBar - для показа на StartActivity.

- <a href="https://github.com/square/leakcanary">LeakCanary</a> для обнаружения утечек памяти на этапе отладки. Благодаря ему обнаружил, что SlidingSquaresLoader необходимо останавливать при закрытии Activity, иначе возникает небольшой (очень небольшой, но все же!) Memory Leak. 

Дополнительно - для Layout старался выбирать ConstraintLayout от Google, поскольку этот Layout заявлен как более быстрый и удобный, чем, к примеру, RelativeLayout. В 2016 на этапе беты у ConstraintLayout был ряд неприятных багов (к примеру, перенос текста во вложенных TextView), но сейчас в релизной версии он выглядит надежным. 
